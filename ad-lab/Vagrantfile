# -*- mode: ruby -*-
# vi: set ft=ruby :

# This vagrantfile has a lot of workarounds for the limitations of Vagrant
# and the VMWare Workstation provider.

# Vagrantfile API/syntax version. Don't touch unless you know what you're doing!
VAGRANTFILE_API_VERSION = "2"

require 'yaml'

# Load the provision.yaml file
conf    = YAML.load_file(File.join(File.dirname(__FILE__), 'provision.yaml'))
servers = conf['servers']
vars    = conf['vars']
vdiskmgr_path = '"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmware-vdiskmanager.exe"'

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  servers.each do |server|
    config.vm.define server["name"] do |srv|
      srv.vm.box      = server["box"]
      srv.vm.hostname = server["name"]

      # Use the plaintext WinRM transport and force it to use basic authentication.
      # NB this is needed because the default negotiate transport stops working
      #    after the domain controller is installed.
      #    see https://groups.google.com/forum/#!topic/vagrant-up/sZantuCM0q4
      srv.winrm.transport = :plaintext
      srv.winrm.basic_auth_only = true

      # VMware specific configuration
      srv.vm.provider "vmware_desktop" do |vm|
        vm.vmx["cpuid.coresPerSocket"]  = "1"
        vm.vmx["memsize"]               = server['memory'] || "1024"
        vm.vmx["numvcpus"]              = server['cpus'] || "2"
        vm.gui = true

        # Configure network settings for an additional network adapter
        if server.key?("net")
          vm.vmx["ethernet1.vnet"]        = server['net']['vnet'] || "VMnet1"
          vm.vmx["ethernet1.displayName"] = server['net']['vnet'] || "VMnet1"
          vm.vmx["ethernet1.virtualDev"]  = server['net']['virtualdev'] || "e1000e"
          vm.vmx["ethernet1.present"]     = "TRUE"
        end

        # Configure VMWare Provider to create DHCP reservations
        if server.key?("staticip")
          vm.base_address = server["staticip"]["base_address"]
          vm.base_mac     = server["staticip"]["base_mac"]
        end

        #
        # Handle disk configuration
        # Initialize a disk number counter, loop through defined disks,
        # create the disk if it doesn't exist, and add it to the VM configuration.
        if server.key?("disks")
          disk_number = 1
          server["disks"].each do |disk|
            extra_disk_dir  = File.join(File.expand_path(File.dirname(__FILE__)), "extra-disks/#{server['name']}")
            extra_disk_path = "#{extra_disk_dir}/#{disk['name']}.vmdk".gsub('/', '\\')

            unless File.directory?(extra_disk_dir)
              Dir.mkdir(extra_disk_dir)
            end

            unless File.exists?(extra_disk_path)
              system("#{vdiskmgr_path} -c -s #{disk['size']}GB -t 0 \"#{extra_disk_path}\"")
            end

            # Add disk to VM configuration
            vm.vmx["nvme0:#{disk_number}.fileName"] = extra_disk_path
            vm.vmx["nvme0:#{disk_number}.present"] = "TRUE"
            vm.vmx["nvme0:#{disk_number}.redo"] = ""

            # Increment the disk number for the next disk
            disk_number += 1            
          end #end disks.each
        end #end if server.key?("disks")
      end #end vm.provider "vmware_desktop"

      # Configure the VM
      if vars.key?("locale")
        sys_tz = vars['locale']['timezone'] || 'Eastern Standard Time'
        sys_lc = vars['locale']['culture'] || 'en-US'
        srv.vm.provision "shell", path: "scripts/provision/configure-locale.ps1", privileged: true, args: "'#{sys_lc}', '#{sys_tz}'"
        srv.vm.provision "shell", reboot: true
      end
      
      srv.vm.provision "shell", path: "scripts/provision/reletter-cdrom.ps1", privileged: true
      srv.vm.provision "shell", path: "scripts/provision/initialize-disks.ps1", privileged: true
      srv.vm.provision "shell", path: "scripts/provision/configure-filesystem.ps1", privileged: false
      srv.vm.provision "shell", path: "scripts/provision/configure-firewall.ps1", privileged: false
      srv.vm.provision "shell", path: "scripts/provision/install-pwsh-v7.ps1", privileged: true
      srv.vm.provision "shell", reboot: true
      srv.vm.provision "shell", path: "scripts/provision/install-choco.ps1", privileged: true

      if server.key?("packages")
        srv.vm.provision "shell", path: "scripts/provision/install-chocopackages.ps1", privileged: true, args: server["packages"]
      else
        srv.vm.provision "shell", path: "scripts/provision/install-chocopackages.ps1", privileged: true
      end

      # Check if 'roles' key is defined and is an Array
      if server.key?("roles") && server["roles"].is_a?(Array)
        # Loop through each role and apply necessary provisioning
        server["roles"].each do |role|
          case role
            when "domain-controller"
              srv.vm.provision "shell", path: "scripts/roles/domain-controller/install-adds.ps1", privileged: true, args: "'#{vars['domainname']}' '#{vars['netbiosname']}' '#{vars['safemodepassword']}'"
              srv.vm.provision "shell", reboot: true
              srv.vm.provision "shell", path: "scripts/roles/domain-controller/importusers.ps1", privileged: false
            when "member-server"
              srv.vm.provision "shell", path: "scripts/roles/member-server/join-domain.ps1", privileged: true, args: "'#{vars['domainname']}' '#{vars['primarydns']}'"
            when "powershelluniversal"
              irms_account  = vars['irms']&.[]('account')   # safe navigation operator; set to nil if not found
              irms_password = vars['irms']&.[]('password')  # safe navigation operator; set to nil if not found
              srv.vm.provision "shell", path: "scripts/provision/configure-servercore.ps1", privileged: false
              srv.vm.provision "shell", path: "scripts/provision/add-rsatadtools.ps1", privileged: true
              srv.vm.provision "shell", path: "scripts/provision/add-rsatadposh.ps1", privileged: true
              srv.vm.provision "shell", reboot: true
              srv.vm.provision "shell", path: "scripts/roles/powershelluniversal/install-pwshuniversal.ps1", privileged: true, args: "'#{irms_account}' '#{irms_password}'"
              srv.vm.provision "shell", reboot: true
          end #end case role
        end # end role loop
      end # end role check
      srv.vm.provision "shell", path: "scripts/utils/export-ipinfo.ps1", privileged: false
    end #end config.vm.define
  end #end servers.each
end
